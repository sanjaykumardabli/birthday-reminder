# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python

name: Python application

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]


permissions:
  contents: read

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Get branch name
      shell: bash
      run: |
        if [[ ${GITHUB_EVENT_NAME} == "pull_request" ]]
        then
           echo "BRANCH_NAME=$(echo ${GITHUB_HEAD_REF})" >> $GITHUB_ENV
           echo "Branch name: ${GITHUB_HEAD_REF}"
        else
           echo "BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/})" >> $GITHUB_ENV
           echo "Branch name: ${GITHUB_REF#refs/heads/}"        
        fi

    - name: Run id
      run: echo ${{ github.run_id }}
    
    - name: Get workflow id
      shell: bash
      run: |
        WORKFLOW_ID=$(curl --header 'authorization: Bearer ${{ github.token }}' \
                           --header 'content-type: application/json' \
        ${{ github.api_url }}/repos/${{ github.repository }}/actions/runs/${{ github.run_id }} | jq -r .workflow_id)
        echo "WORKFLOW_ID=$WORKFLOW_ID" >> $GITHUB_ENV
        echo "Workflow id: ${WORKFLOW_ID}"

    - name: Get previous build status
      shell: bash
      id: last_status
      run: |
        last_status=$(curl --silent --header 'authorization: Bearer ${{ github.token }}' \
                                    --header 'content-type: application/json' \
        "${{ github.api_url }}/repos/${{ github.repository }}/actions/workflows/${{ env.WORKFLOW_ID }}/runs?per_page=1&status=completed&branch=${{ env.BRANCH_NAME }}" \
        | jq -r .workflow_runs[0].conclusion)
        echo "::set-output name=last_status::$last_status"
        echo "Status of the previous build: $last_status"
    
    - name: print last build status
      run: echo ${{ steps.last_status.outputs.last_status }}
    
    - name: set previous status
      if: ${{ always() }}
      id: old_status
      run: echo "old_status=failure" >> $GITHUB_ENV

    - name: print old_status
      run: echo ${{ steps.old_status.outputs.old_status }}
    
    - name: print current status
      run: echo ${{ job.status }}

    - name: Send slack message if on failure
      uses: gdcorp-action-public-forks/action-slack-notifY@v2
      id: slack_notification
      if: ${{ job.status == 'failure' }}

      env:
        SLACK_WEBHOOK: https://hooks.slack.com/services/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
        SLACK_MESSAGE: $SLACK_MESSAGE
      continue-on-error: true
    
    - name: check failure status
      run: echo ${{ steps.slack_notification.outcome }}

    - name: print old_status again
      run: echo ${{ job.status }}
      
    - name: Send slack message if on rebuild
      uses: gdcorp-action-public-forks/action-slack-notifY@v2
      if: ${{ (steps.slack_notification.outcome == 'skipped')  && (steps.old_status.outputs.old_status == 'failure') && (job.status == 'success' ) }}
      id: slack_notification_rebuild

      env:
        SLACK_WEBHOOK: https://hooks.slack.com/services/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
        SLACK_MESSAGE: $SLACK_MESSAGE
      continue-on-error: true

    - name: check failure status
      run: echo ${{ steps.slack_notification_rebuild.outcome }}

    - name: Condition
      run: echo ${{ steps.slack_notification_rebuild.outcome == 'skipped' }}

    - name: Condition 2
      run: echo ${{ (steps.slack_notification.outcome == 'skipped')  && (steps.old_status.outputs.old_status == 'failure') && (job.status == 'success' ) }}

    - name: Condition 3
      run: echo ${{ (steps.slack_notification.outcome == 'skipped') }}
    
    - name: Condition 4
      run: echo ${{ (steps.old_status.outputs.old_status== 'failure') }}
    
    - name: Condition 5
      run: echo ${{ (job.status == 'success' ) }}
 
